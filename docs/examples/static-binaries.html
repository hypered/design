<!DOCTYPE html><html><head><link rel="stylesheet" href="/static/css/main.css"></head><body><header><div class="o-container--small c-base"><div class="c-navbar c-navbar--main"><div class="c-toolbar"><div class="c-toolbar__left"><div class="c-toolbar__item"><a>noteed.com</a></div><div class="c-toolbar__item"><a>blog</a></div><div class="c-toolbar__item"><a>notes</a></div><div class="c-toolbar__item"><a>nix-notes</a></div><div class="c-toolbar__item"><a>not-os</a></div><div class="c-toolbar__item"><a>videos</a></div></div></div></div></div></header><div class="o-container--small c-content"><h1>Static binaries</h1><p>If you consider adopting a programming language, consider one where you can create statically-linked executables. This makes things so much easier.</p><hr><h2>E.g., compared to Docker</h2><p>With a statically-linked binary, provisioning a program on a remote host is just uploading it. With Docker, you need to install and maintain docker-engine. Ideally you should have a nice way to provision the remote host with Docker, but then, why not use that nice way to provision other stuff directly ?</p><p>Docker is much more than packaging, but it seems a lot of people use it for that purpose.</p><p>By the way, statically-linked executables make building Docker images a breeze.</p><p>If you use Docker to deploy, you probably want a private registry, which is another piece to maintain. Static binaries are trivial to host on a static site. Or to mirror. And so on. Simplicity goes a long way.</p><hr class="u-spacer-bottom-m"><p>See also: <a>In praise of simplicity</a></p><hr class="u-spacer-bottom-m"><p>Related: <a>Learn packaging</a></p><hr class="u-spacer-top-l u-spacer-bottom-l"><p class="u-spacer-bottom-m">© Võ Minh Thu, 2017-2023.</p></div></body></html>